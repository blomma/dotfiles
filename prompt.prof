Time	Sum	Command
1735	18526	> builtin source /usr/local/Cellar/fish/3.0.0/share/fish/config.fish
86	86	-> set -g IFS \n\ \t
44	44	-> set -qg __fish_added_user_paths
37	37	-> set -g __fish_added_user_paths
30	30	-> function __fish_default_command_not_found_handler
    printf "fish: Unknown command '%s'\n" (string escape -- $argv) >&2
...
10	705	-> if status --is-interactive
    # The user has seemingly explicitly launched an old fish with too-new scripts installed.
    if not contains -- "string" (builtin -n)
        set -g __is_launched_without_string 1
        # XXX nostring - fix old fish binaries with no `string' builtin.
        # When executed on fish 2.2.0, the `else' block after this would
        # force on 24-bit mode due to changes to in test behavior.
        # These "XXX nostring" hacks were added for 2.3.1
        set_color --bold
        echo "You appear to be trying to launch an old fish binary with newer scripts "
        echo "installed into" (set_color --underline)"$__fish_data_dir"
        set_color normal
        echo -e "\nThis is an unsupported configuration.\n"
        set_color yellow
        echo "You may need to uninstall and reinstall fish!"
        set_color normal
        # Remove this code when we've made it safer to upgrade fish.
    else
        # Enable truecolor/24-bit support for select terminals
        # Ignore Screen and emacs' ansi-term as they swallow the sequences, rendering the text white.
        if not set -q STY
            and not string match -q -- 'eterm*' $TERM
            and begin
                set -q KONSOLE_PROFILE_NAME # KDE's konsole
                or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
                or string match -q -- "st-*" $TERM # suckless' st
                or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
                or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
            end
            # Only set it if it isn't to allow override by setting to 0
            set -q fish_term24bit
            or set -g fish_term24bit 1
        end
    end
else
    # Hook up the default as the principal command_not_found handler
    # in case we are not interactive
    function __fish_command_not_found_handler --on-event fish_command_not_found
        __fish_default_command_not_found_handler $argv
    end
...
39	39	--> status --is-interactive
10	656	--> if not contains -- "string" (builtin -n)
        set -g __is_launched_without_string 1
        # XXX nostring - fix old fish binaries with no `string' builtin.
        # When executed on fish 2.2.0, the `else' block after this would
        # force on 24-bit mode due to changes to in test behavior.
        # These "XXX nostring" hacks were added for 2.3.1
        set_color --bold
        echo "You appear to be trying to launch an old fish binary with newer scripts "
        echo "installed into" (set_color --underline)"$__fish_data_dir"
        set_color normal
        echo -e "\nThis is an unsupported configuration.\n"
        set_color yellow
        echo "You may need to uninstall and reinstall fish!"
        set_color normal
        # Remove this code when we've made it safer to upgrade fish.
    else
        # Enable truecolor/24-bit support for select terminals
        # Ignore Screen and emacs' ansi-term as they swallow the sequences, rendering the text white.
        if not set -q STY
            and not string match -q -- 'eterm*' $TERM
            and begin
                set -q KONSOLE_PROFILE_NAME # KDE's konsole
                or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
                or string match -q -- "st-*" $TERM # suckless' st
                or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
                or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
            end
            # Only set it if it isn't to allow override by setting to 0
            set -q fish_term24bit
            or set -g fish_term24bit 1
        end
    ...
260	347	---> not contains -- "string" (builtin -n)
87	87	----> builtin -n
16	299	---> if not set -q STY
            and not string match -q -- 'eterm*' $TERM
            and begin
                set -q KONSOLE_PROFILE_NAME # KDE's konsole
                or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
                or string match -q -- "st-*" $TERM # suckless' st
                or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
                or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
            end
            # Only set it if it isn't to allow override by setting to 0
            set -q fish_term24bit
            or set -g fish_term24bit 1
        ...
36	36	----> not set -q STY
73	73	----> not string match -q -- 'eterm*' $TERM
19	103	----> begin
                set -q KONSOLE_PROFILE_NAME # KDE's konsole
                or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
                or string match -q -- "st-*" $TERM # suckless' st
                or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
                or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
            ...
35	35	-----> set -q KONSOLE_PROFILE_NAME
49	49	-----> string match -q -- "*:*" $ITERM_SESSION_ID
27	27	----> set -q fish_term24bit
44	44	----> set -g fish_term24bit 1
56	56	-> set -g __fish_config_dir ~/.config/fish
3	35	-> if set -q XDG_CONFIG_HOME
    set __fish_config_dir $XDG_CONFIG_HOME/fish
...
32	32	--> set -q XDG_CONFIG_HOME
44	44	-> set -l userdatadir ~/.local/share
3	35	-> if set -q XDG_DATA_HOME
    set userdatadir $XDG_DATA_HOME
...
32	32	--> set -q XDG_DATA_HOME
33	33	-> set -l __extra_completionsdir
32	32	-> set -l __extra_functionsdir
35	35	-> set -l __extra_confdir
12	401	-> if test -f $__fish_data_dir/__fish_build_paths.fish
    source $__fish_data_dir/__fish_build_paths.fish
...
90	90	--> test -f $__fish_data_dir/__fish_build_paths.fish
178	299	--> source $__fish_data_dir/__fish_build_paths.fish
46	46	---> set __extra_completionsdir /usr/local/share/fish/vendor_completions.d
40	40	---> set __extra_functionsdir /usr/local/share/fish/vendor_functions.d
35	35	---> set __extra_confdir /usr/local/share/fish/vendor_conf.d
10	113	-> if not set -q fish_function_path
    set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $__extra_functionsdir $__fish_data_dir/functions
...
31	31	--> not set -q fish_function_path
72	72	--> set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $__extra_functionsdir $__fish_data_dir/functions
3	132	-> if not contains -- $__fish_data_dir/functions $fish_function_path
    set fish_function_path $fish_function_path $__fish_data_dir/functions
...
129	129	--> not contains -- $__fish_data_dir/functions $fish_function_path
17	131	-> if not set -q fish_complete_path
    set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $__extra_completionsdir $__fish_data_dir/completions $userdatadir/fish/generated_completions
...
31	31	--> not set -q fish_complete_path
83	83	--> set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $__extra_completionsdir $__fish_data_dir/completions $userdatadir/fish/generated_completions
4	68	-> if not contains -- $__fish_data_dir/completions $fish_complete_path
    set fish_complete_path $fish_complete_path $__fish_data_dir/completions
...
64	64	--> not contains -- $__fish_data_dir/completions $fish_complete_path
8	8	-> function :
    # no-op function for compatibility with sh, bash, and others.
    # Often used to insert a comment into a chain of commands without having
	# it eat up the remainder of the line, handy in Makefiles.
...
4	45	-> if test -d /usr/xpg4/bin
    if not contains -- /usr/xpg4/bin $PATH
        set PATH /usr/xpg4/bin $PATH
    end
...
41	41	--> test -d /usr/xpg4/bin
24	24	-> function __fish_reconstruct_path -d "Update PATH when fish_user_paths changes" --on-variable fish_user_paths
    set -l local_path $PATH

    for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    end

    set -g __fish_added_user_paths
    if set -q fish_user_paths
        for x in $fish_user_paths[-1..1]
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -g __fish_added_user_paths $__fish_added_user_paths $x
            end
            set local_path $x $local_path
        end
    end

    set -xg PATH $local_path
...
57	57	-> function fish_sigtrap_handler --on-signal TRAP --no-scope-shadowing --description "Signal handler for the TRAP signal. Launches a debug prompt."
    breakpoint
...
17	17	-> function __fish_on_interactive --on-event fish_prompt
    __fish_config_interactive
    functions -e __fish_on_interactive
...
170	1324	-> __fish_set_locale
688	704	--> source /usr/local/Cellar/fish/3.0.0/share/fish/functions/__fish_set_locale.fish
16	16	---> function __fish_set_locale
    set -l LOCALE_VARS
    set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
    set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
    set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION

    # We check LC_ALL to figure out if we have a locale but we don't set it later. That is because
    # locale.conf doesn't allow it so we should not set it.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end

    # Try to extract the locale from the kernel boot commandline. The splitting here is a bit weird,
    # but we operate under the assumption that the locale can't include whitespace. Other whitespace
    # shouldn't concern us, but a quoted "locale.LANG=SOMETHING" as a value to something else might.
    # Here the last definition of a variable takes precedence.
    if test -r /proc/cmdline
        for var in (string match -ra 'locale.[^=]+=\S+' < /proc/cmdline)
            set -l kv (string replace 'locale.' '' -- $var | string split '=')
            # Only set locale variables, not other stuff contained in these files - this also
            # automatically ignores comments.
            if contains -- $kv[1] $LOCALE_VARS
                and set -q kv[2]
                set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
            end
        end
    end

    # Now read the config files we know are used by various OS distros.
    #
    # /etc/sysconfig/i18n is for old Red Hat derivatives (and possibly of no use anymore).
    #
    # /etc/env.d/02locale is from OpenRC.
    #
    # The rest are systemd inventions but also used elsewhere (e.g. Void Linux). systemd's
    # documentation is a bit unclear on this. We merge all the config files (and the commandline),
    # which seems to be what systemd itself does. (I.e. the value for a variable will be taken from
    # the highest-precedence source) We read the systemd files first since they are a newer
    # invention and therefore the rest are likely to be accumulated cruft.
    #
    # NOTE: Slackware puts the locale in /etc/profile.d/lang.sh, which we can't use because it's a
    # full POSIX-shell script.
    set -l user_cfg_dir (set -q XDG_CONFIG_HOME; and echo $XDG_CONFIG_HOME; or echo ~/.config)
    for f in $user_cfg_dir/locale.conf /etc/locale.conf /etc/env.d/02locale /etc/sysconfig/i18n
        if test -r $f
            while read -l kv
                set kv (string split '=' -- $kv)
                if contains -- $kv[1] $LOCALE_VARS
                    and set -q kv[2]
                    # Do not set already set variables again - this makes the merging happen.
                    if not set -q $kv[1]
                        set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
                    end
                end
            end <$f
        end
    end

    # If we really cannot get anything, at least set character encoding to UTF-8.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end
    set -gx LC_CTYPE en_US.UTF-8
...
47	47	--> set -l LOCALE_VARS
52	52	--> set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
53	53	--> set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
54	54	--> set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION
68	244	--> for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    ...
4	53	---> if set -q $locale_var
            return 0
        ...
49	49	----> set -q $locale_var
3	41	---> if set -q $locale_var
            return 0
        ...
38	38	----> set -q $locale_var
10	82	---> if set -q $locale_var
            return 0
        ...
40	40	----> set -q $locale_var
32	32	----> return 0
20	20	-> function . --description 'Evaluate contents of file (deprecated, see "source")' --no-scope-shadowing
    if test (count $argv) -eq 0
        # Uses tty directly, as isatty depends on "."
        and tty 0>&0 >/dev/null
        echo "source: '.' command is deprecated, and doesn't work with STDIN anymore. Did you mean 'source' or './'?" >&2
        return 1
    else
        source $argv
    end
...
3	40	-> if not set -q __fish_init_2_3_0
    if set -q fish_user_abbreviations
        set -l fab
        for abbr in $fish_user_abbreviations
            set fab $fab (string replace -r '^([^ =]+)=(.*)$' '$1 $2' -- $abbr)
        end
        set fish_user_abbreviations $fab
    end
    set -U __fish_init_2_3_0
...
37	37	--> not set -q __fish_init_2_3_0
19	4641	-> if command -sq /usr/libexec/path_helper
    # Adapt construct_path from the macOS /usr/libexec/path_helper
    # executable for fish; see
    # https://opensource.apple.com/source/shell_cmds/shell_cmds-203/path_helper/path_helper.c.auto.html .
    function __fish_macos_set_env -d "set an environment variable like path_helper does (macOS only)"
        set -l result

        for path_file in $argv[2] $argv[3]/*
            if test -f $path_file
                while read -la entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
            end
        end

        for entry in $$argv[1]
            if not contains $entry $result
                set result $result $entry
            end
        end

        set -xg $argv[1] $result
    end

    __fish_macos_set_env 'PATH' '/etc/paths' '/etc/paths.d'
    if [ -n "$MANPATH" ]
        __fish_macos_set_env 'MANPATH' '/etc/manpaths' '/etc/manpaths.d'
    end
    functions -e __fish_macos_set_env
...
87	87	--> command -sq /usr/libexec/path_helper
22	22	--> function __fish_macos_set_env -d "set an environment variable like path_helper does (macOS only)"
        set -l result

        for path_file in $argv[2] $argv[3]/*
            if test -f $path_file
                while read -la entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
            end
        end

        for entry in $$argv[1]
            if not contains $entry $result
                set result $result $entry
            end
        end

        set -xg $argv[1] $result
    ...
53	4403	--> __fish_macos_set_env 'PATH' '/etc/paths' '/etc/paths.d'
42	42	---> set -l result
437	2449	---> for path_file in $argv[2] $argv[3]/*
            if test -f $path_file
                while read -la entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
            end
        ...
20	797	----> if test -f $path_file
                while read -la entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
            ...
67	67	-----> test -f $path_file
151	710	-----> while read -la entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
69	69	------> read -la entry
26	85	------> if not contains $entry $result
                        set result $result $entry
                    ...
34	34	-------> not contains $entry $result
25	25	-------> set result $result $entry
28	28	------> read -la entry
14	69	------> if not contains $entry $result
                        set result $result $entry
                    ...
25	25	-------> not contains $entry $result
30	30	-------> set result $result $entry
25	25	------> read -la entry
15	67	------> if not contains $entry $result
                        set result $result $entry
                    ...
25	25	-------> not contains $entry $result
27	27	-------> set result $result $entry
25	25	------> read -la entry
13	69	------> if not contains $entry $result
                        set result $result $entry
                    ...
27	27	-------> not contains $entry $result
29	29	-------> set result $result $entry
25	25	------> read -la entry
12	77	------> if not contains $entry $result
                        set result $result $entry
                    ...
33	33	-------> not contains $entry $result
32	32	-------> set result $result $entry
20	20	------> read -la entry
18	298	----> if test -f $path_file
                while read -la entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
            ...
57	57	-----> test -f $path_file
70	223	-----> while read -la entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
36	36	------> read -la entry
24	97	------> if not contains $entry $result
                        set result $result $entry
                    ...
34	34	-------> not contains $entry $result
39	39	-------> set result $result $entry
20	20	------> read -la entry
18	289	----> if test -f $path_file
                while read -la entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
            ...
52	52	-----> test -f $path_file
67	219	-----> while read -la entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
33	33	------> read -la entry
24	99	------> if not contains $entry $result
                        set result $result $entry
                    ...
35	35	-------> not contains $entry $result
40	40	-------> set result $result $entry
20	20	------> read -la entry
16	300	----> if test -f $path_file
                while read -la entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
            ...
50	50	-----> test -f $path_file
70	234	-----> while read -la entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
34	34	------> read -la entry
24	110	------> if not contains $entry $result
                        set result $result $entry
                    ...
43	43	-------> not contains $entry $result
43	43	-------> set result $result $entry
20	20	------> read -la entry
17	328	----> if test -f $path_file
                while read -la entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
            ...
50	50	-----> test -f $path_file
73	261	-----> while read -la entry
                    if not contains $entry $result
                        set result $result $entry
                    end
                end <$path_file
33	33	------> read -la entry
24	133	------> if not contains $entry $result
                        set result $result $entry
                    ...
57	57	-------> not contains $entry $result
52	52	-------> set result $result $entry
22	22	------> read -la entry
128	1765	---> for entry in $$argv[1]
            if not contains $entry $result
                set result $result $entry
            end
        ...
16	141	----> if not contains $entry $result
                set result $result $entry
            ...
59	59	-----> not contains $entry $result
66	66	-----> set result $result $entry
16	142	----> if not contains $entry $result
                set result $result $entry
            ...
62	62	-----> not contains $entry $result
64	64	-----> set result $result $entry
15	135	----> if not contains $entry $result
                set result $result $entry
            ...
55	55	-----> not contains $entry $result
65	65	-----> set result $result $entry
14	136	----> if not contains $entry $result
                set result $result $entry
            ...
56	56	-----> not contains $entry $result
66	66	-----> set result $result $entry
16	146	----> if not contains $entry $result
                set result $result $entry
            ...
56	56	-----> not contains $entry $result
74	74	-----> set result $result $entry
15	148	----> if not contains $entry $result
                set result $result $entry
            ...
58	58	-----> not contains $entry $result
75	75	-----> set result $result $entry
16	147	----> if not contains $entry $result
                set result $result $entry
            ...
59	59	-----> not contains $entry $result
72	72	-----> set result $result $entry
3	70	----> if not contains $entry $result
                set result $result $entry
            ...
67	67	-----> not contains $entry $result
3	67	----> if not contains $entry $result
                set result $result $entry
            ...
64	64	-----> not contains $entry $result
4	62	----> if not contains $entry $result
                set result $result $entry
            ...
58	58	-----> not contains $entry $result
2	61	----> if not contains $entry $result
                set result $result $entry
            ...
59	59	-----> not contains $entry $result
3	61	----> if not contains $entry $result
                set result $result $entry
            ...
58	58	-----> not contains $entry $result
3	67	----> if not contains $entry $result
                set result $result $entry
            ...
64	64	-----> not contains $entry $result
3	62	----> if not contains $entry $result
                set result $result $entry
            ...
59	59	-----> not contains $entry $result
3	60	----> if not contains $entry $result
                set result $result $entry
            ...
57	57	-----> not contains $entry $result
3	60	----> if not contains $entry $result
                set result $result $entry
            ...
57	57	-----> not contains $entry $result
2	72	----> if not contains $entry $result
                set result $result $entry
            ...
70	70	-----> not contains $entry $result
94	94	---> set -xg $argv[1] $result
2	37	--> if [ -n "$MANPATH" ]
        __fish_macos_set_env 'MANPATH' '/etc/manpaths' '/etc/manpaths.d'
    ...
35	35	---> [ -n "$MANPATH" ]
73	73	--> functions -e __fish_macos_set_env
3	31	-> if status --is-login
    #
    # Put linux consoles in unicode mode.
    #
    if test "$TERM" = linux
        if string match -qir '\.UTF' -- $LANG
            if command -sq unicode_start
                unicode_start
            end
        end
    end
...
28	28	--> status --is-login
38	292	-> __fish_reconstruct_path
78	78	--> set -l local_path $PATH
23	23	--> for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    ...
30	30	--> set -g __fish_added_user_paths
2	31	--> if set -q fish_user_paths
        for x in $fish_user_paths[-1..1]
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -g __fish_added_user_paths $__fish_added_user_paths $x
            end
            set local_path $x $local_path
        end
    ...
29	29	---> set -q fish_user_paths
92	92	--> set -xg PATH $local_path
10	10	-> function __fish_expand_pid_args
    for arg in $argv
        if string match -qr '^%\d+$' -- $arg
            # set newargv $newargv (jobs -p $arg)
            jobs -p $arg
            if not test $status -eq 0
                return 1
            end
        else
            printf "%s\n" $arg
        end
    end
...
10	10	-> function bg --wraps bg
    builtin bg (__fish_expand_pid_args $argv)
...
6	6	-> function fg --wraps fg
    builtin fg (__fish_expand_pid_args $argv)
...
7	7	-> function kill --wraps kill
    command kill (__fish_expand_pid_args $argv)
...
7	7	-> function wait --wraps wait
    builtin wait (__fish_expand_pid_args $argv)
...
9	9	-> function disown --wraps disown
    builtin disown (__fish_expand_pid_args $argv)
...
31	31	-> set -l sourcelist
399	8195	-> for file in $__fish_config_dir/conf.d/*.fish $__fish_sysconf_dir/conf.d/*.fish $__extra_confdir/*.fish
    set -l basename (string replace -r '^.*/' '' -- $file)
    contains -- $basename $sourcelist
    and continue
    set sourcelist $sourcelist $basename
    # Also skip non-files or unreadable files.
    # This allows one to use e.g. symlinks to /dev/null to "mask" something (like in systemd).
    [ -f $file -a -r $file ]
    and source $file
...
89	983	--> set -l basename (string replace -r '^.*/' '' -- $file)
301	894	---> string replace -r '^.*/' '' -- $file
296	593	----> source /usr/local/Cellar/fish/3.0.0/share/fish/functions/string.fish
5	297	-----> if not contains string (builtin -n)
    function string
        if not set -q __is_launched_without_string
            if status --is-interactive
                # We've been autoloaded after fish < 2.3.0 upgraded to >= 2.3.1 - no string builtin
                set_color --bold >&2
                echo "Fish has been upgraded, and the scripts on your system are not compatible" >&2
                echo "with this prior instance of fish. You can probably run:" >&2
                set_color green >&2
                echo -e "\n exec fish" >&2
                set_color normal >&2
                echo "… to replace this process with a new one in-place." >&2
                set -g __is_launched_without_string 1
            end
        end
        set -p PATH $__fish_bin_dir
        set string_cmd string \'$argv\'

        if fish -c 'contains string (builtin -n)'
            fish -c "$string_cmd"
        else
            return 127
        end
    end
...
217	292	------> not contains string (builtin -n)
75	75	-------> builtin -n
42	42	--> contains -- $basename $sourcelist
38	38	--> set sourcelist $sourcelist $basename
76	76	--> [ -f $file -a -r $file ]
169	413	--> source $file
37	37	---> set -g theme_display_git yes
30	30	---> set -g theme_display_git_dirty yes
34	34	---> set -g theme_display_git_untracked yes
24	24	---> set -g theme_display_git_ahead_verbose yes
24	24	---> set -g theme_display_git_dirty_verbose yes
24	24	---> set -g theme_display_git_master_branch yes
24	24	---> set -g theme_display_cmd_duration no
24	24	---> set -g theme_color_scheme terminal-dark
23	23	---> set -g theme_display_date no
73	127	--> set -l basename (string replace -r '^.*/' '' -- $file)
54	54	---> string replace -r '^.*/' '' -- $file
36	36	--> contains -- $basename $sourcelist
35	35	--> set sourcelist $sourcelist $basename
64	64	--> [ -f $file -a -r $file ]
162	2664	--> source $file
159	2338	---> set -l host (echo $hostname | string lower  | string replace ".local" "")
2179	2179	----> echo $hostname | string lower  | string replace ".local" ""
56	56	---> set -l LOCAL_CONFIG "$HOME/.config/fish"
46	46	---> set -l host_specific_file $LOCAL_CONFIG/hosts/$host.fish
4	62	---> if test -f $host_specific_file
    source $host_specific_file
...
58	58	----> test -f $host_specific_file
101	184	--> set -l basename (string replace -r '^.*/' '' -- $file)
83	83	---> string replace -r '^.*/' '' -- $file
54	54	--> contains -- $basename $sourcelist
57	57	--> set sourcelist $sourcelist $basename
70	70	--> [ -f $file -a -r $file ]
275	2953	--> source $file
4	44	---> if test -z "$Z_DATA"
  if test -z "$XDG_DATA_HOME"
    set -U Z_DATA_DIR "$HOME/.local/share/z"
  else 
    set -U Z_DATA_DIR "$XDG_DATA_HOME/z"
  end
  set -U Z_DATA "$Z_DATA_DIR/data"
...
40	40	----> test -z "$Z_DATA"
2	52	---> if test ! -e "$Z_DATA"
  if test ! -e "$Z_DATA_DIR"
    mkdir -p -m 700 "$Z_DATA_DIR"  
  end
  touch "$Z_DATA"
...
50	50	----> test ! -e "$Z_DATA"
3	35	---> if test -z "$Z_CMD"
  set -U Z_CMD "z"
...
32	32	----> test -z "$Z_CMD"
51	51	---> set -U ZO_CMD "$Z_CMD"o
6	61	---> if test ! -z $Z_CMD
  function $Z_CMD -d "jump around"
    __z $argv
  end
...
33	33	----> test ! -z $Z_CMD
22	22	----> function $Z_CMD -d "jump around"
    __z $argv
  ...
4	49	---> if test ! -z $ZO_CMD
  function $ZO_CMD -d "open target dir"
    __z -d $argv
  end
...
30	30	----> test ! -z $ZO_CMD
15	15	----> function $ZO_CMD -d "open target dir"
    __z -d $argv
  ...
2	28	---> if not set -q Z_EXCLUDE
  set -U Z_EXCLUDE $HOME
...
26	26	----> not set -q Z_EXCLUDE
143	2337	---> __z_complete
201	216	----> source /Users/blomma/.config/fish/functions/__z_complete.fish
15	15	-----> function __z_complete -d "add completions"
  set -l __z_marks (string replace -r '\|.*' '' < $Z_DATA | string escape)

  complete -c $Z_CMD -a "$__z_marks" -f
  complete -c $ZO_CMD -a "$__z_marks" -f

  complete -c $Z_CMD -s c -l clean  -d "Cleans out $Z_DATA"
  complete -c $Z_CMD -s e -l echo   -d "Prints best match, no cd"
  complete -c $Z_CMD -s l -l list   -d "List matches, no cd"
  complete -c $Z_CMD -s p -l purge  -d "Purges $Z_DATA"
  complete -c $Z_CMD -s r -l rank   -d "Searches by rank, cd"
  complete -c $Z_CMD -s t -l recent -d "Searches by recency, cd"
  complete -c $Z_CMD -s h -l help   -d "Print help"
...
202	1395	----> set -l __z_marks (string replace -r '\|.*' '' < $Z_DATA | string escape)
1193	1193	-----> string replace -r '\|.*' '' < $Z_DATA | string escape
171	171	----> complete -c $Z_CMD -a "$__z_marks" -f
103	103	----> complete -c $ZO_CMD -a "$__z_marks" -f
54	54	----> complete -c $Z_CMD -s c -l clean  -d "Cleans out $Z_DATA"
44	44	----> complete -c $Z_CMD -s e -l echo   -d "Prints best match, no cd"
41	41	----> complete -c $Z_CMD -s l -l list   -d "List matches, no cd"
45	45	----> complete -c $Z_CMD -s p -l purge  -d "Purges $Z_DATA"
40	40	----> complete -c $Z_CMD -s r -l rank   -d "Searches by rank, cd"
44	44	----> complete -c $Z_CMD -s t -l recent -d "Searches by recency, cd"
41	41	----> complete -c $Z_CMD -s h -l help   -d "Print help"
21	21	---> function __z_on_variable_pwd --on-variable PWD
  __z_add
...
100	100	> builtin source /usr/local/Cellar/fish/3.0.0/etc/fish/config.fish
297	225785	> builtin source /Users/blomma/.config/fish/config.fish
43	43	-> set fish_greeting "くコ:彡 welcome to fish"
260	900	-> source ~/.config/fish/color.fish
34	34	--> set fish_color_autosuggestion 9C9C9C
27	27	--> set fish_color_command F4F4F4
26	26	--> set fish_color_comment B0B0B0
24	24	--> set fish_color_cwd green
25	25	--> set fish_color_cwd_root red
24	24	--> set fish_color_end 969696
24	24	--> set fish_color_error FFA779
23	23	--> set fish_color_escape cyan
23	23	--> set fish_color_history_current cyan
28	28	--> set fish_color_host \x2do\x1ecyan
24	24	--> set fish_color_match cyan
24	24	--> set fish_color_normal normal
23	23	--> set fish_color_operator cyan
25	25	--> set fish_color_param A0A0F0
24	24	--> set fish_color_quote 666A80
24	24	--> set fish_color_redirection FAFAFA
28	28	--> set fish_color_search_match \x2d\x2dbackground\x3dpurple
28	28	--> set fish_color_selection \x2d\x2dbackground\x3dpurple
24	24	--> set fish_color_status red
27	27	--> set fish_color_user \x2do\x1egreen
28	28	--> set fish_color_valid_path \x2d\x2dunderline
28	28	--> set fish_pager_color_completion normal
28	28	--> set fish_pager_color_description 555\x1eyellow
23	23	--> set fish_pager_color_prefix cyan
24	24	--> set fish_pager_color_progress cyan
49	49	-> set -gx LC_ALL en_US.UTF-8
30	30	-> set -gx EDITOR "vim"
29	29	-> set -gx VISUAL "$EDITOR"
19	220050	-> if status --is-interactive
    abbr --add --global tma tmux attach -d -t

    ### Ruby (rbenv) ###
    if command -s rbenv >/dev/null
        rbenv init -| source
    end

    ### Python (pyenv) ###
    if command -s pyenv >/dev/null
        pyenv init -| source
    end
...
23	23	--> status --is-interactive
149	2670	--> abbr --add --global tma tmux attach -d -t
1029	1080	---> source /usr/local/Cellar/fish/3.0.0/share/fish/functions/abbr.fish
15	15	----> function abbr --description "Manage abbreviations"
    set -l options --stop-nonopt --exclusive 'a,r,e,l,s' --exclusive 'g,U'
    set -a options 'h/help' 'a/add' 'r/rename' 'e/erase' 'l/list' 's/show'
    set -a options 'g/global' 'U/universal'

    argparse -n abbr $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help abbr
        return 0
    end

    # If run with no options, treat it like --add if we have arguments, or
    # --show if we do not have any arguments.
    set -l _flag_add
    set -l _flag_show
    if not set -q _flag_add[1]
        and not set -q _flag_rename[1]
        and not set -q _flag_erase[1]
        and not set -q _flag_list[1]
        and not set -q _flag_show[1]
        if set -q argv[1]
            set _flag_add --add
        else
            set _flag_show --show
        end
    end

    set -l abbr_scope
    if set -q _flag_global
        set abbr_scope --global
    else if set -q _flag_universal
        set abbr_scope --universal
    end

    if set -q _flag_add[1]
        __fish_abbr_add $argv
        return
    else if set -q _flag_erase[1]
        __fish_abbr_erase $argv
        return
    else if set -q _flag_rename[1]
        __fish_abbr_rename $argv
        return
    else if set -q _flag_list[1]
        __fish_abbr_list $argv
        return
    else if set -q _flag_show[1]
        __fish_abbr_show $argv
        return
    else
        printf ( _ "%s: Could not figure out what to do!\n" ) abbr >&2
        return 127
    end
...
10	10	----> function __fish_abbr_add --no-scope-shadowing
    if not set -q argv[2]
        printf ( _ "%s %s: Requires at least two arguments\n" ) abbr --add >&2
        return 1
    end

    # Because of the way abbreviations are expanded there can't be any spaces in the key.
    set -l abbr_name $argv[1]
    set -l escaped_abbr_name (string escape -- $abbr_name)
    if string match -q "* *" -- $abbr_name
        set -l msg ( _ "%s %s: Abbreviation %s cannot have spaces in the word\n" )
        printf $msg abbr --add $escaped_abbr_name >&2
        return 1
    end

    set -l abbr_val "$argv[2..-1]"
    set -l abbr_var_name _fish_abbr_(string escape --style=var -- $abbr_name)

    if not set -q $abbr_var_name
        # We default to the universal scope if the user didn't explicitly specify a scope and the
        # abbreviation isn't already defined.
        set -q abbr_scope[1]
        or set abbr_scope --universal
    end
    true # make sure the next `set` command doesn't leak the previous status
    set $abbr_scope $abbr_var_name $abbr_val
...
7	7	----> function __fish_abbr_erase --no-scope-shadowing
    if set -q argv[2]
        printf ( _ "%s %s: Expected one argument\n" ) abbr --erase >&2
        return 1
    end

    # Because of the way abbreviations are expanded there can't be any spaces in the key.
    set -l abbr_name $argv[1]
    set -l escaped_name (string escape -- $abbr_name)
    if string match -q "* *" -- $abbr_old_name
        set -l msg ( _ "%s %s: Abbreviation %s cannot have spaces in the word\n" )
        printf $msg abbr --erase $escaped_name >&2
        return 1
    end

    set -l abbr_var_name _fish_abbr_(string escape --style=var -- $abbr_name)

    if not set -q $abbr_var_name
        printf ( _ "%s %s: No abbreviation named %s\n" ) abbr --erase $escaped_name >&2
        return 121
    end

    set -e $abbr_var_name
...
7	7	----> function __fish_abbr_rename --no-scope-shadowing
    if test (count $argv) -ne 2
        printf ( _ "%s %s: Requires exactly two arguments\n" ) abbr --rename >&2
        return 1
    end

    set -l old_name $argv[1]
    set -l new_name $argv[2]
    set -l escaped_old_name (string escape -- $old_name)
    set -l escaped_new_name (string escape -- $new_name)
    if string match -q "* *" -- $old_name
        set -l msg ( _ "%s %s: Abbreviation %s cannot have spaces in the word\n" )
        printf $msg abbr --rename $escaped_old_name >&2
        return 1
    end
    if string match -q "* *" -- $new_name
        set -l msg ( _ "%s %s: Abbreviation %s cannot have spaces in the word\n" )
        printf $msg abbr --rename $escaped_new_name >&2
        return 1
    end

    set -l old_var_name _fish_abbr_(string escape --style=var -- $old_name)
    set -l new_var_name _fish_abbr_(string escape --style=var -- $new_name)

    if not set -q $old_var_name
        printf ( _ "%s %s: No abbreviation named %s\n" ) abbr --rename $escaped_old_name >&2
        return 1
    end
    if set -q $new_var_name
        set -l msg ( _ "%s %s: Abbreviation %s already exists, cannot rename %s\n" )
        printf $msg abbr --rename $escaped_new_name $escaped_old_name >&2
        return 1
    end

    set -l old_var_val $$old_var_name

    if not set -q abbr_scope[1]
        # User isn't forcing the scope so use the existing scope.
        if set -ql $old_var_name
            set abbr_scope --global
        else
            set abbr_scope --universal
        end
    end

    set -e $old_var_name
    set $abbr_scope $new_var_name $old_var_val
...
6	6	----> function __fish_abbr_list --no-scope-shadowing
    if set -q argv[1]
        printf ( _ "%s %s: Unexpected argument -- '%s'\n" ) abbr --erase $argv[1] >&2
        return 1
    end

    for var_name in (set --names)
        string match -q '_fish_abbr_*' $var_name
        or continue

        set -l abbr_name (string unescape --style=var (string sub -s 12 $var_name))
        echo $abbr_name
    end
...
6	6	----> function __fish_abbr_show --no-scope-shadowing
    if set -q argv[1]
        printf ( _ "%s %s: Unexpected argument -- '%s'\n" ) abbr --erase $argv[1] >&2
        return 1
    end

    for var_name in (set --names)
        string match -q '_fish_abbr_*' $var_name
        or continue

        set -l abbr_var_name $var_name
        set -l abbr_name (string unescape --style=var -- (string sub -s 12 $abbr_var_name))
        set -l abbr_name (string escape --style=script -- $abbr_name)
        set -l abbr_val $$abbr_var_name
        set -l abbr_val (string escape --style=script -- $abbr_val)

        if set -ql $abbr_var_name
            printf 'abbr -a %s -- %s %s\n' -l $abbr_name $abbr_val
        end
        if set -qg $abbr_var_name
            printf 'abbr -a %s -- %s %s\n' -g $abbr_name $abbr_val
        end
        if set -qU $abbr_var_name
            printf 'abbr -a %s -- %s %s\n' -U $abbr_name $abbr_val
        end
    end
...
46	46	---> set -l options --stop-nonopt --exclusive 'a,r,e,l,s' --exclusive 'g,U'
50	50	---> set -a options 'h/help' 'a/add' 'r/rename' 'e/erase' 'l/list' 's/show'
47	47	---> set -a options 'g/global' 'U/universal'
115	115	---> argparse -n abbr $options -- $argv
3	29	---> if set -q _flag_help
        __fish_print_help abbr
        return 0
    ...
26	26	----> set -q _flag_help
26	26	---> set -l _flag_add
23	23	---> set -l _flag_show
15	179	---> if not set -q _flag_add[1]
        and not set -q _flag_rename[1]
        and not set -q _flag_erase[1]
        and not set -q _flag_list[1]
        and not set -q _flag_show[1]
        if set -q argv[1]
            set _flag_add --add
        else
            set _flag_show --show
        end
    ...
23	23	----> not set -q _flag_add[1]
23	23	----> not set -q _flag_rename[1]
21	21	----> not set -q _flag_erase[1]
22	22	----> not set -q _flag_list[1]
21	21	----> not set -q _flag_show[1]
6	54	----> if set -q argv[1]
            set _flag_add --add
        else
            set _flag_show --show
        ...
24	24	-----> set -q argv[1]
24	24	-----> set _flag_add --add
24	24	---> set -l abbr_scope
7	52	---> if set -q _flag_global
        set abbr_scope --global
    else if set -q _flag_universal
        set abbr_scope --universal
    ...
22	22	----> set -q _flag_global
23	23	----> set abbr_scope --global
11	850	---> if set -q _flag_add[1]
        __fish_abbr_add $argv
        return
    else if set -q _flag_erase[1]
        __fish_abbr_erase $argv
        return
    else if set -q _flag_rename[1]
        __fish_abbr_rename $argv
        return
    else if set -q _flag_list[1]
        __fish_abbr_list $argv
        return
    else if set -q _flag_show[1]
        __fish_abbr_show $argv
        return
    else
        printf ( _ "%s: Could not figure out what to do!\n" ) abbr >&2
        return 127
    ...
24	24	----> set -q _flag_add[1]
160	784	----> __fish_abbr_add $argv
4	52	-----> if not set -q argv[2]
        printf ( _ "%s %s: Requires at least two arguments\n" ) abbr --add >&2
        return 1
    ...
48	48	------> not set -q argv[2]
45	45	-----> set -l abbr_name $argv[1]
97	145	-----> set -l escaped_abbr_name (string escape -- $abbr_name)
48	48	------> string escape -- $abbr_name
3	42	-----> if string match -q "* *" -- $abbr_name
        set -l msg ( _ "%s %s: Abbreviation %s cannot have spaces in the word\n" )
        printf $msg abbr --add $escaped_abbr_name >&2
        return 1
    ...
39	39	------> string match -q "* *" -- $abbr_name
38	38	-----> set -l abbr_val "$argv[2..-1]"
71	109	-----> set -l abbr_var_name _fish_abbr_(string escape --style=var -- $abbr_name)
38	38	------> string escape --style=var -- $abbr_name
9	63	-----> if not set -q $abbr_var_name
        # We default to the universal scope if the user didn't explicitly specify a scope and the
        # abbreviation isn't already defined.
        set -q abbr_scope[1]
        or set abbr_scope --universal
    ...
29	29	------> not set -q $abbr_var_name
25	25	------> set -q abbr_scope[1]
55	55	-----> true
75	75	-----> set $abbr_scope $abbr_var_name $abbr_val
31	31	----> return
74	190104	--> if command -s rbenv >/dev/null
        rbenv init -| source
    ...
1491	1491	---> command -s rbenv >/dev/null
75979	188539	---> rbenv init -| source
115	115	----> set -gx PATH '/Users/blomma/.rbenv/shims' $PATH
25	25	----> set -gx RBENV_SHELL fish
229	55625	----> source '/usr/local/Cellar/rbenv/HEAD-59785f6/libexec/../completions/rbenv.fish'
20	20	-----> function __fish_rbenv_needs_command
  set cmd (commandline -opc)
  if [ (count $cmd) -eq 1 -a $cmd[1] = 'rbenv' ]
    return 0
  end
  return 1
...
6	6	-----> function __fish_rbenv_using_command
  set cmd (commandline -opc)
  if [ (count $cmd) -gt 1 ]
    if [ $argv[1] = $cmd[2] ]
      return 0
    end
  end
  return 1
...
48	48	-----> complete -f -c rbenv -n '__fish_rbenv_needs_command' -a '(rbenv commands)'
358	55322	-----> for cmd in (rbenv commands)
  complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
...
53777	53777	------> rbenv commands
88	88	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
48	48	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
43	43	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
52	52	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
46	46	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
42	42	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
43	43	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
42	42	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
49	49	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
43	43	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
43	43	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
43	43	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
44	44	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
41	41	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
43	43	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
42	42	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
48	48	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
43	43	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
44	44	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
44	44	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
48	48	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
43	43	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
43	43	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
43	43	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
40	40	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
39	39	------> complete -f -c rbenv -n "__fish_rbenv_using_command $cmd" -a \
    "(rbenv completions (commandline -opc)[2..-1])"
56766	56766	----> command rbenv rehash 2>/dev/null
29	29	----> function rbenv
  set command $argv[1]
  set -e argv[1]

  switch "$command"
  case rehash shell
    source (rbenv "sh-$command" $argv|psub)
  case '*'
    command rbenv "$command" $argv
  end
...
11	27234	--> if command -s pyenv >/dev/null
        pyenv init -| source
    ...
27223	27223	---> command -s pyenv >/dev/null
302	302	-> set -gx PATH $HOME/go/bin $PATH
434	434	-> set -gx PATH $HOME/.bin $PATH
138	138	-> set -gx PATH $HOME/opt/bin $PATH
164	164	-> set -gx PATH $HOME/.pyenv/bin $PATH
136	136	-> set -gx PATH $HOME/.rbenv/bin $PATH
118	118	-> set -gx PATH /home/linuxbrew/.linuxbrew/bin $PATH
4	3095	-> if not functions -q fisher
    set -q XDG_CONFIG_HOME
    or set XDG_CONFIG_HOME ~/.config
    curl https://git.io/fisher --create-dirs -sLo $XDG_CONFIG_HOME/fish/functions/fisher.fish
    fish -c fisher
...
157	3091	--> not functions -q fisher
2709	2934	---> source /Users/blomma/.config/fish/functions/fisher.fish
82	82	----> set -g fisher_version 3.2.4
23	23	----> function fisher -a cmd -d "fish package manager"
    set -q XDG_CACHE_HOME; or set XDG_CACHE_HOME ~/.cache
    set -q XDG_CONFIG_HOME; or set XDG_CONFIG_HOME ~/.config

    set -g fish_config $XDG_CONFIG_HOME/fish
    set -g fisher_cache $XDG_CACHE_HOME/fisher
    set -g fisher_config $XDG_CONFIG_HOME/fisher

    set -q fisher_path; or set -g fisher_path $fish_config

    for path in {$fish_config,$fisher_path}/{functions,completions,conf.d} $fisher_cache
        if test ! -d $path
            command mkdir -p $path
        end
    end

    if test ! -e $fisher_path/completions/fisher.fish
        echo "fisher self-complete" >$fisher_path/completions/fisher.fish
        _fisher_self_complete
    end

    if test -e $fisher_path/conf.d/fisher.fish
        switch "$version"
            case \*-\*
                command rm -f $fisher_path/conf.d/fisher.fish
            case 2\*
            case \*
                command rm -f $fisher_path/conf.d/fisher.fish
        end
    else
        switch "$version"
            case \*-\*
            case 2\*
                echo "fisher copy-user-key-bindings" >$fisher_path/conf.d/fisher.fish
        end
    end

    switch "$cmd"
        case self-complete
            _fisher_self_complete
        case copy-user-key-bindings
            _fisher_copy_user_key_bindings
        case ls
            set -e argv[1]
            _fisher_ls | _fisher_fmt | _fisher_filter | command awk "/$argv[1]/"
        case self-update
            _fisher_self_update (status -f)
        case self-uninstall
            _fisher_self_uninstall
        case -v {,--}version
            _fisher_version (status -f)
        case -h {,--}help
            _fisher_help
        case ""
            _fisher_commit --
        case add rm
            if not isatty
                while read -l arg
                    set argv $argv $arg
                end
            end

            if test (count $argv) = 1
                echo "invalid number of arguments" >&2
                _fisher_help >&2
                return 1
            end

            _fisher_commit $argv
        case \*
            echo "unknown flag or command \"$cmd\"" >&2
            _fisher_help >&2
            return 1
    end
...
7	7	----> function _fisher_self_complete
    complete -ec fisher
    complete -xc fisher -n __fish_use_subcommand -a add -d "Add packages"
    complete -xc fisher -n __fish_use_subcommand -a rm -d "Remove packages"
    complete -xc fisher -n __fish_use_subcommand -a ls -d "List installed packages"
    complete -xc fisher -n __fish_use_subcommand -a help -d "Show usage help"
    complete -xc fisher -n __fish_use_subcommand -a version -d "$fisher_version"
    complete -xc fisher -n __fish_use_subcommand -a self-update -d "Update to the latest version"
    for pkg in (_fisher_ls | _fisher_fmt | _fisher_filter)
        complete -xc fisher -n "__fish_seen_subcommand_from rm" -a $pkg
    end
...
6	6	----> function _fisher_copy_user_key_bindings
    if functions -q fish_user_key_bindings
        functions -c fish_user_key_bindings fish_user_key_bindings_copy
    end
    function fish_user_key_bindings
        for file in $fisher_path/conf.d/*_key_bindings.fish
            source $file >/dev/null 2>/dev/null
        end
        if functions -q fish_user_key_bindings_copy
            fish_user_key_bindings_copy
        end
    end
...
6	6	----> function _fisher_ls
    for pkg in $fisher_config/*/*/*
        command readlink $pkg; or echo $pkg
    end
...
5	5	----> function _fisher_fmt
    command sed "s|^[[:space:]]*||;s|^$fisher_config/||;s|^$HOME|~|;s|^\.\/|$PWD/|;s|^github\.com/||;s|^https*://||;s|/*\$||"
...
7	7	----> function _fisher_file -a file
    set -e argv[1]
    _fisher_fmt < $file | _fisher_read $argv
...
6	6	----> function _fisher_filter
    set -l file (_fisher_file $fisher_path/fishfile)
    command awk -v FILE="$file" '
        BEGIN {
            n = split(FILE, file, " ")
            for (i = 1; i <= n; i++) found[file[i]] = i
        }
        found[$0]
    '
...
6	6	----> function _fisher_version -a file
    echo "fisher version $fisher_version $file" | command sed "s|$HOME|~|"
...
4	4	----> function _fisher_help
    echo "usage:"
    echo "       fisher add <PACKAGES>    Add packages"
    echo "       fisher rm  <PACKAGES>    Remove packages"
    echo "       fisher                   Update all packages"
    echo "       fisher ls  [REGEX]       List installed packages matching REGEX"
    echo "       fisher help              Show this help"
    echo "       fisher version           Show the current version"
    echo "       fisher self-update       Update to the latest version"
    echo "       fisher self-uninstall    Uninstall from your system"
    echo
    echo "examples:"
    echo "       fisher add jethrokuan/z rafaelrinaldi/pure"
    echo "       fisher add gitlab.com/foo/bar@v2"
    echo "       fisher add ~/path/to/local/pkg"
    echo "       fisher add < bundle"
    echo "       fisher rm rafaelrinaldi/pure"
    echo "       fisher rm rafaelrinaldi/pure"
    echo "       fisher ls | fisher rm"
    echo "       fisher ls fish-\*"
...
7	7	----> function _fisher_self_update -a file
    set -l url "https://raw.githubusercontent.com/jorgebucaran/fisher/master/fisher.fish"
    echo "fetching $url" >&2
    command curl -s "$url?nocache" >$file.

    set -l next_version (command awk 'NR == 1 { print $4 }' < $file.)
    switch "$next_version"
        case "" $fisher_version
            command rm -f $file.
            if test -z "$next_version"
                echo "cannot update fisher -- are you offline?" >&2
                return 1
            end
            echo "fisher is already up-to-date" >&2
        case \*
            echo "linking $file" | command sed "s|$HOME|~|" >&2
            command mv -f $file. $file
            source $file
            echo "updated to $fisher_version -- hooray!" >&2
            _fisher_self_complete
    end
...
5	5	----> function _fisher_self_uninstall
    for pkg in (_fisher_ls)
        _fisher_rm $pkg
    end

    for file in $fisher_cache $fisher_config $fisher_path/{functions,completions,conf.d}/fisher.fish $fisher_path/fishfile
        echo "removing $file"
        command rm -Rf $file 2>/dev/null
    end | command sed "s|$HOME|~|" >&2

    for name in (set -n | command awk '/^fisher_/')
        set -e "$name"
    end

    complete -c fisher --erase
    functions -e (functions -a | command awk '/^_fisher/') fisher

    echo "done -- see you again!" >&2
...
6	6	----> function _fisher_commit -a cmd
    set -e argv[1]
    set -l elapsed (_fisher_now)
    set -l fishfile $fisher_path/fishfile

    if test ! -e "$fishfile"
        command touch $fishfile
        echo "created new fishfile in $fishfile" | command sed "s|$HOME|~|" >&2
    end

    set -l rm_pkgs (_fisher_ls | _fisher_fmt)
    for pkg in (_fisher_ls)
        _fisher_rm $pkg
    end
    command rm -Rf $fisher_config
    command mkdir -p $fisher_config

    set -l next_pkgs (_fisher_file $fishfile $cmd (printf "%s\n" $argv | _fisher_fmt))
    set -l new_pkgs (_fisher_fetch $next_pkgs)
    set -l old_pkgs
    for pkg in $rm_pkgs
        if contains -- $pkg $new_pkgs
            set old_pkgs $old_pkgs $pkg
        end
    end

    if test -z "$new_pkgs$old_pkgs$rm_pkgs$next_pkgs"
        echo "nothing to commit -- try adding some packages" >&2
        return 1
    end

    set -l actual_pkgs
    if test "$cmd" = "rm"
        set actual_pkgs $next_pkgs
    else
        for pkg in $next_pkgs
            if contains -- (echo $pkg | command sed "s|@.*||") $new_pkgs
                set actual_pkgs $actual_pkgs $pkg
            end
        end
    end

    _fisher_fmt <$fishfile | _fisher_write $cmd $actual_pkgs >$fishfile.
    command mv -f $fishfile. $fishfile

    _fisher_self_complete

    command awk -v N=(count $new_pkgs) -v O=(count $old_pkgs) -v R=(count $rm_pkgs) -v E=(_fisher_now $elapsed) '
        BEGIN {
            if (N = N - O) res = msg(res, "added", N)
            if (O) res = msg(res, "updated", O)
            if (R = R - O) res = msg(res, "removed", R)
            printf((res ? res : "done") " in %.2fs\n", E / 1000)
        }
        function msg(res, str, n) {
            return (res ? res ", " : "") str " " n " package" (n > 1 ? "s" : "")
        }
    ' >&2
...
9	9	----> function _fisher_read -a cmd
    set -e argv[1]
    command awk -v FS="[[:space:]]*#" -v CMD="$cmd" -v ARGS="$argv" '
        BEGIN {
            split(ARGS, args, " ")
            for (i in args) {
                if (!((k = getkey(args[i])) in pkgs)) {
                    pkgs[k] = args[i]
                    if (CMD == "add") out[n++] = args[i]
                }
            }
        }
        !/^#/ && NF {
            if (!file[k = getkey($1)]++ && !(k in pkgs)) out[n++] = $1
        }
        END {
            for (i = 0; i < n; i++) print out[i]
            if (CMD == "rm") {
                for (pkg in pkgs) {
                    if (!(pkg in file)) {
                        print "cannot remove \""pkg"\" -- package not listed in fishfile" > "/dev/stderr"
                    }
                }
            }
        }
        function getkey(s) {
            return (split(s, a, /@+|:/) > 2) ? a[2]"/"a[1]"/"a[3] : a[1]
        }
    '
...
6	6	----> function _fisher_write -a cmd
    set -e argv[1]
    command awk -v CMD="$cmd" -v ARGS="$argv" '
        BEGIN {
            split(ARGS, args, " ")
            for (i in args) pkgs[getkey(args[i])] = args[i]
        }
        {
            if (/^#/ || !NF) print $0
            else {
                k = getkey($0)
                if (out = pkgs[k] != 0 ? pkgs[k] : CMD != "rm" ? $0 : "") print out
                pkgs[k] = 0
            }
        }
        END {
            for (k in pkgs) if (pkgs[k]) print pkgs[k]
        }
        function getkey(s) {
            return (split(s, a, /@+|:/) > 2) ? a[2]"/"a[1]"/"a[3] : a[1]
        }
    '
...
5	5	----> function _fisher_fetch
    set -l pkg_jobs
    set -l next_pkgs
    set -l local_pkgs
    set -l actual_pkgs
    set -q fisher_user_api_token; and set -l user_info -u $fisher_user_api_token

    for i in $argv
        switch $i
            case \~\* /\*
                set -l path (echo "$i" | command sed "s|~|$HOME|")
                if test -e "$path"
                    set local_pkgs $local_pkgs $path
                else
                    echo "cannot add \"$i\" -- is this a valid file?" >&2
                end
                continue
        end

        command awk -v NAME=$i -v FS=/ '
            BEGIN {
                if (split(NAME, tmp, /@+|:/) > 2) {
                    if (tmp[4]) sub("@"tmp[4], "", NAME)
                    print NAME "\t" tmp[2]"/"tmp[1]"/"tmp[3] "\t" (tmp[4] ? tmp[4] : "master")
                } else {
                    pkg = split(NAME, _, "/") <= 2 ? "github.com/"tmp[1] : tmp[1]
                    tag = tmp[2] ? tmp[2] : "master"
                    print (\
                        pkg ~ /^github/ ? "https://codeload."pkg"/tar.gz/"tag : \
                        pkg ~ /^gitlab/ ? "https://"pkg"/-/archive/"tag"/"tmp[split(pkg, tmp, "/")]"-"tag".tar.gz" : \
                        pkg ~ /^bitbucket/ ? "https://"pkg"/get/"tag".tar.gz" : pkg \
                    ) "\t" pkg
                }
            }
        ' | read -l url pkg branch

        if test ! -d "$fisher_config/$pkg"
            fish -c "
                echo fetching $url >&2
                command mkdir -p $fisher_config/$pkg $fisher_cache/(dirname $pkg)
                if test ! -z \"$branch\"
                     command git clone $url $fisher_config/$pkg --branch $branch --depth 1 2>/dev/null
                     or echo cannot clone \"$url\" -- is this a valid url\? >&2
                else if command curl $user_info -Ss $url 2>&1 | command tar -xzf- -C $fisher_config/$pkg 2>/dev/null
                    command rm -Rf $fisher_cache/$pkg
                    command mv -f $fisher_config/$pkg/* $fisher_cache/$pkg
                    command rm -Rf $fisher_config/$pkg
                    command cp -Rf {$fisher_cache,$fisher_config}/$pkg
                else if test -d \"$fisher_cache/$pkg\"
                    echo cannot connect to server -- searching in \"$fisher_cache/$pkg\" | command sed 's|$HOME|~|' >&2
                    command cp -Rf $fisher_cache/$pkg $fisher_config/$pkg/..
                else
                    command rm -Rf $fisher_config/$pkg
                    echo cannot add \"$pkg\" -- is this a valid package\? >&2
                end
            " >/dev/null &

            set pkg_jobs $pkg_jobs (_fisher_jobs --last)
            set next_pkgs $next_pkgs "$fisher_config/$pkg"
        end
    end

    if test ! -z "$pkg_jobs"
        _fisher_wait $pkg_jobs
        for pkg in $next_pkgs
            if test -d "$pkg"
                set actual_pkgs $actual_pkgs $pkg
                _fisher_add $pkg
            end
        end
    end

    set -l local_path $fisher_config/local/$USER
    for src in $local_pkgs
        command mkdir -p $local_path
        command ln -sf $src $local_path/(command basename $src)
        set actual_pkgs $actual_pkgs $src
        _fisher_add $src --link
    end

    if test ! -z "$actual_pkgs"
        _fisher_fetch (_fisher_deps $actual_pkgs | command awk '!seen[$0]++')
        printf "%s\n" $actual_pkgs | _fisher_fmt
    end
...
5	5	----> function _fisher_deps
    for pkg in $argv
        if test ! -d "$pkg"
            echo $pkg
        else if test -s "$pkg/fishfile"
            _fisher_deps (_fisher_fmt < $pkg/fishfile | _fisher_read)
        end
    end
...
6	6	----> function _fisher_add -a pkg opts
    set -l name (command basename $pkg)
    set -l files $pkg/{functions,completions,conf.d}/**.* $pkg/*.fish
    for src in $files
        set -l target (command basename $src)
        switch $src
            case $pkg/conf.d\*
                set target $fisher_path/conf.d/$target
            case $pkg/completions\*
                set target $fisher_path/completions/$target
            case $pkg/{functions,}\*
                switch $target
                    case uninstall.fish
                        continue
                    case init.fish key_bindings.fish
                        set target $fisher_path/conf.d/$name\_$target
                    case \*
                        set target $fisher_path/functions/$target
                end
        end
        echo "linking $target" | command sed "s|$HOME|~|" >&2
        if test -z "$opts"
            command cp -f $src $target
        else
            command ln -sf $src $target
        end
        switch $target
            case \*.fish
                source $target >/dev/null 2>/dev/null
        end
    end
...
7	7	----> function _fisher_rm -a pkg
    set -l name (command basename $pkg)
    set -l files $pkg/{conf.d,completions,functions}/**.* $pkg/*.fish
    for src in $files
        set -l target (command basename $src)
        set -l filename (command basename $target .fish)
        switch $src
            case $pkg/conf.d\*
                test "$filename.fish" = "$target"; and emit "$filename"_uninstall
                set target conf.d/$target
            case $pkg/completions\*
                test "$filename.fish" = "$target"; and complete -ec $filename
                set target completions/$target
            case $pkg/{,functions}\*
                test "$filename.fish" = "$target"; and functions -e $filename
                switch $target
                    case uninstall.fish
                        source $src
                        continue
                    case init.fish key_bindings.fish
                        set target conf.d/$name\_$target
                    case \*
                        set target functions/$target
                end
        end
        command rm -f $fisher_path/$target
    end
    if not functions -q fish_prompt
        source "$__fish_datadir$__fish_data_dir/functions/fish_prompt.fish"
    end
...
5	5	----> function _fisher_jobs
    jobs $argv | command awk '/^[0-9]+\t/ { print $1 }'
...
5	5	----> function _fisher_wait
    while for job in $argv
            contains -- $job (_fisher_jobs); and break
        end
    end
...
7	7	----> function _fisher_now -a elapsed
    switch (command uname)
        case Darwin \*BSD
            command perl -MTime::HiRes -e 'printf("%.0f\n", (Time::HiRes::time() * 1000) - $ARGV[0])' $elapsed
        case \*
            math (command date "+%s%3N") - "0$elapsed"
    end
...
205	196494	> fish_prompt
359	382	-> source /Users/blomma/.config/fish/functions/fish_prompt.fish
12	12	--> function _git_branch_name
  echo (command git symbolic-ref HEAD 2> /dev/null | sed -e 's|^refs/heads/||')
...
6	6	--> function _git_is_dirty
  echo (command git status -s --ignore-submodules=dirty 2> /dev/null)
...
5	5	--> function fish_prompt
  set -l last_status $status

  set -l cyan (set_color cyan)
  set -l yellow (set_color yellow)
  set -l red (set_color red)
  set -l blue (set_color blue)
  set -l green (set_color green)
  set -l normal (set_color normal)

  set -l cwd $blue(pwd | sed "s:^$HOME:~:")

  # Output the prompt, left to right

  # Add a newline before new prompts
  echo -e ''

  # Display [venvname] if in a virtualenv
  if set -q VIRTUAL_ENV
      echo -n -s (set_color -b cyan black) '[' (basename "$VIRTUAL_ENV") ']' $normal ' '
  end

  # Print pwd or full path
  echo -n -s $cwd $normal

  # Show git branch and status
  if [ (_git_branch_name) ]
    set -l git_branch (_git_branch_name)

    if [ (_git_is_dirty) ]
      set git_info '(' $yellow $git_branch "±" $normal ')'
    else
      set git_info '(' $green $git_branch $normal ')'
    end
    echo -n -s ' · ' $git_info $normal
  end

  set -l prompt_color $red
  if test $last_status = 0
    set prompt_color $normal
  end

  # Terminate with a nice prompt char
  echo -e ''
  echo -e -n -s $prompt_color '⟩ ' $normal
...
43	43	-> set -l last_status $status
76	191	-> set -l cyan (set_color cyan)
115	115	--> set_color cyan
69	109	-> set -l yellow (set_color yellow)
40	40	--> set_color yellow
64	107	-> set -l red (set_color red)
43	43	--> set_color red
63	98	-> set -l blue (set_color blue)
35	35	--> set_color blue
63	98	-> set -l green (set_color green)
35	35	--> set_color green
64	99	-> set -l normal (set_color normal)
35	35	--> set_color normal
171	28748	-> set -l cwd $blue(pwd | sed "s:^$HOME:~:")
28577	28577	--> pwd | sed "s:^$HOME:~:"
88	88	-> echo -e ''
4	62	-> if set -q VIRTUAL_ENV
      echo -n -s (set_color -b cyan black) '[' (basename "$VIRTUAL_ENV") ']' $normal ' '
  ...
58	58	--> set -q VIRTUAL_ENV
90	90	-> echo -n -s $cwd $normal
32	165832	-> if [ (_git_branch_name) ]
    set -l git_branch (_git_branch_name)

    if [ (_git_is_dirty) ]
      set git_info '(' $yellow $git_branch "±" $normal ')'
    else
      set git_info '(' $green $git_branch $normal ')'
    end
    echo -n -s ' · ' $git_info $normal
  ...
122	62659	--> [ (_git_branch_name) ]
134	62537	---> _git_branch_name
134	62403	----> echo (command git symbolic-ref HEAD 2> /dev/null | sed -e 's|^refs/heads/||')
62269	62269	-----> command git symbolic-ref HEAD 2> /dev/null | sed -e 's|^refs/heads/||'
91	60425	--> set -l git_branch (_git_branch_name)
32	60334	---> _git_branch_name
180	60302	----> echo (command git symbolic-ref HEAD 2> /dev/null | sed -e 's|^refs/heads/||')
60122	60122	-----> command git symbolic-ref HEAD 2> /dev/null | sed -e 's|^refs/heads/||'
14	42653	--> if [ (_git_is_dirty) ]
      set git_info '(' $yellow $git_branch "±" $normal ')'
    else
      set git_info '(' $green $git_branch $normal ')'
    ...
111	42554	---> [ (_git_is_dirty) ]
92	42443	----> _git_is_dirty
221	42351	-----> echo (command git status -s --ignore-submodules=dirty 2> /dev/null)
42130	42130	------> command git status -s --ignore-submodules=dirty 2> /dev/null
85	85	---> set git_info '(' $yellow $git_branch "±" $normal ')'
63	63	--> echo -n -s ' · ' $git_info $normal
41	41	-> set -l prompt_color $red
19	139	-> if test $last_status = 0
    set prompt_color $normal
  ...
55	55	--> test $last_status = 0
65	65	--> set prompt_color $normal
56	56	-> echo -e ''
106	106	-> echo -e -n -s $prompt_color '⟩ ' $normal
91	91	> exit
